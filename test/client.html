<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Remote Desktop Client</title>
</head>
<body style="margin:0; background:#000; height:100vh; width:100vw; overflow:hidden;">
	<div style="display:flex; flex-direction:column; height:100vh; width:100vw;">
		<!-- 上黒帯 -->
		<div style="flex:0 0 5vh; background:#000;"></div>
		<!-- メインコンテンツ -->
		<div style="flex:1; display:flex; flex-direction:row; align-items:center; justify-content:space-between; background:#000; width:100vw;">
			<!-- 左ボタン -->
			<button id="leftBtn" style="flex:0 0 6vw; height:80vh; margin-left:1vw; font-size:2vw; align-self:center;">◀</button>

			<!-- ビデオ -->
			<div id="videoWrapper" style="flex:1; display:flex; align-items:center; justify-content:center; position:relative;">
				<video id="remoteVideo" autoplay playsinline 
					style="width:100%; max-width:100vw; max-height:80vh; aspect-ratio:16/9; background:#000; border-radius:1vw; box-shadow:0 0 20px #222; display:block;"></video>
				<!-- トラックパッドオーバーレイ（位置・サイズはJSで video の表示領域に合わせる） -->
				<div id="trackpadOverlay" style="position:fixed; top:0; left:0; width:0; height:0; background:rgba(0,0,0,0); z-index:20; touch-action:none;"></div>
			</div>
			<!-- 右ボタン -->
			<button id="rightBtn" style="flex:0 0 6vw; height:80vh; margin-right:1vw; font-size:2vw; align-self:center;">▶</button>
		</div>
		<!-- 下黒帯 -->
		<div style="flex:0 0 5vh; background:#000;"></div>
	</div>

	<!-- メニュー -->
	<div id="menu" style="position:fixed; top:0; right:-200px; width:200px; height:100%; background:#333; color:#fff; box-shadow:-5px 0 10px rgba(0,0,0,0.5); transition:right 0.3s;">
		<button id="connectBtn" style="width:100%; padding:10px; background:#4CAF50; color:#fff; border:none;">接続</button>
		<button id="disconnectBtn" style="width:100%; padding:10px; background:#f44336; color:#fff; border:none;">切断</button>

		<!-- 音量メーター -->
		<div style="margin-top:12px; padding:10px; font-size:14px;">
			<div style="margin-bottom:6px; color:#fff;">受信音量: <span id="volText">0</span>%</div>
			<div style="width:100%; height:12px; background:#555; border-radius:6px; overflow:hidden;">
				<div id="volBar" style="width:0%; height:100%; background:#0f0; transition:width 0.1s;"></div>
			</div>
		</div>

		<!-- 接続状態インジケータ -->
		<div style="padding:10px; font-size:14px; color:#fff;">
			接続状態: <span id="connectionStatus" style="font-weight:bold; color:#f44;">停止中</span>
		</div>
	</div>

	<!-- メニュートグルボタン -->
	<button id="menuToggle" style="position:fixed; top:calc(50% - 40vh); right:0; transform:translateY(0); background:#333; color:#fff; border:none; border-radius:5px 0 0 5px; padding:10px;">＜</button>

	<script>
		const menu = document.getElementById('menu');
		const menuToggle = document.getElementById('menuToggle');
		let menuOpen = false;

		menuToggle.addEventListener('click', () => {
			menuOpen = !menuOpen;
			menu.style.right = menuOpen ? '0' : '-200px';
			menuToggle.textContent = menuOpen ? '>' : '<';
		});

		const connectBtn = document.getElementById('connectBtn');
		const disconnectBtn = document.getElementById('disconnectBtn');
		const ipInput = document.createElement('input');
		ipInput.type = 'text';
		ipInput.placeholder = 'サーバーIP';
		ipInput.style.width = '100%';
		ipInput.style.padding = '10px';
		ipInput.style.marginBottom = '10px';
		menu.insertBefore(ipInput, connectBtn);

		let ws = null;
		let pc = null;
		const video = document.getElementById('remoteVideo');
		let audioCtx = null;
		let isOfferSent = false;
		let candidateQueue = [];
		let analyser = null;
		let dataArray = null;
		let volInterval = null;
		const connectionStatusElem = document.getElementById('connectionStatus');

		function setConnectionStatus(state) {
			if (!connectionStatusElem) return;
			if (state === 'connected') {
				connectionStatusElem.textContent = '接続中';
				connectionStatusElem.style.color = '#0f0';
			} else if (state === 'connecting') {
				connectionStatusElem.textContent = '接続中...';
				connectionStatusElem.style.color = '#ff0';
			} else {
				connectionStatusElem.textContent = '停止中';
				connectionStatusElem.style.color = '#f44';
			}
		}

		// 接続処理
		connectBtn.addEventListener('click', async () => {
			const serverIp = ipInput.value || location.hostname;
			try {
				// WebSocketとPeerConnectionを再生成
				if (ws) {
					ws.close();
				}
				ws = new WebSocket(`ws://${serverIp}:8765`);

				if (pc) {
					pc.close();
				}
				pc = new RTCPeerConnection();

				// トランシーバーを追加
				pc.addTransceiver('video', { direction: 'recvonly' });
				pc.addTransceiver('audio', { direction: 'recvonly' });

				// シグナリング: offer送信
				const offer = await pc.createOffer();
				// ユーザー操作（接続ボタン）で AudioContext を生成
				audioCtx = new (window.AudioContext || window.webkitAudioContext)();
				await pc.setLocalDescription(offer);
				const handleWsOpen = () => {
					ws.send(JSON.stringify({ sdp: offer.sdp, type: offer.type }));
					isOfferSent = true;
					// バッファした candidate を送信
					while (candidateQueue.length) {
						const c = candidateQueue.shift();
						ws.send(JSON.stringify({ type: 'candidate', candidate: c }));
					}
				};
				ws.onopen = handleWsOpen;
				// WebSocket が既に開いている場合（稀）すぐにハンドラを実行
				if (ws.readyState === WebSocket.OPEN) {
					handleWsOpen();
				}

				// シグナリング: answer/ICE candidate受信
				ws.onmessage = async (event) => {
					const msg = JSON.parse(event.data);
					if (msg.type === 'answer') {
						await pc.setRemoteDescription(new RTCSessionDescription(msg));
					} else if (msg.type === 'candidate' && msg.candidate) {
						await pc.addIceCandidate(msg.candidate);
					}
				};

			// -------------------------------
			// トラックパッドオーバーレイ: 入力を WebSocket メッセージに変換
			// -------------------------------
			const overlay = document.getElementById('trackpadOverlay');
			let overlayRect = null;
			function updateOverlay() {
				const rect = video.getBoundingClientRect();
				overlayRect = rect;
				overlay.style.left = rect.left + 'px';
				overlay.style.top = rect.top + 'px';
				overlay.style.width = rect.width + 'px';
				overlay.style.height = rect.height + 'px';
			}
			window.addEventListener('resize', updateOverlay);
			window.addEventListener('scroll', updateOverlay);
			video.addEventListener('loadedmetadata', updateOverlay);
			video.addEventListener('play', updateOverlay);
			setInterval(updateOverlay, 300);

			function sendInput(msg) {
				try {
					if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(msg));
				} catch (e) { /* ignore */ }
			}

			function toNormalized(clientX, clientY) {
				if (!overlayRect) updateOverlay();
				const x = (clientX - overlayRect.left) / overlayRect.width;
				const y = (clientY - overlayRect.top) / overlayRect.height;
				return { x: Math.min(1, Math.max(0, x)), y: Math.min(1, Math.max(0, y)) };
			}

			// トラックパッド風の相対移動: 正規化された dx/dy を送信
			let lastClientPos = null;
			let relRafScheduled = false;
			let relAccum = { dx: 0, dy: 0 };
			let isTouchActive = false; // タッチ後の合成マウスイベントを抑制するフラグ
			function scheduleRelativeMove(normDx, normDy) {
				// 小さな差分を蓄積し、rAF ごとに送信
				relAccum.dx += normDx;
				relAccum.dy += normDy;
				if (relRafScheduled) return;
				relRafScheduled = true;
				requestAnimationFrame(() => {
					relRafScheduled = false;
					const send = { type: 'input', input: 'mouse', action: 'move', dx: relAccum.dx, dy: relAccum.dy };
					relAccum.dx = 0; relAccum.dy = 0;
					sendInput(send);
				});
			}

			let mouseStartTime = 0;
			let mouseMoved = false;
			overlay.addEventListener('mousedown', (e) => {
				if (isTouchActive) return; // タッチ由来の合成マウスイベントを無視
				e.preventDefault();
				lastClientPos = { x: e.clientX, y: e.clientY };
				mouseStartTime = Date.now();
				mouseMoved = false;
				// ここでは down を送らない（クリック判定は mouseup で行う）
			});
			overlay.addEventListener('mousemove', (e) => {
				if (isTouchActive) return;
				e.preventDefault();
				if (!overlayRect) updateOverlay();
				if (lastClientPos == null) {
					lastClientPos = { x: e.clientX, y: e.clientY };
					return;
				}
				const dx = e.clientX - lastClientPos.x;
				const dy = e.clientY - lastClientPos.y;
				if (Math.hypot(dx, dy) > TAP_MOVE_PX) mouseMoved = true;
				lastClientPos = { x: e.clientX, y: e.clientY };
				const normDx = dx / overlayRect.width;
				const normDy = dy / overlayRect.height;
				scheduleRelativeMove(normDx, normDy);
			});
			overlay.addEventListener('mouseup', (e) => {
				if (isTouchActive) return;
				e.preventDefault();
				const dt = Date.now() - mouseStartTime;
				// 短いクリック（移動なし）はクリック扱いにする: 単一の click メッセージを送信
				if (!mouseMoved && dt <= TAP_MAX_MS) {
					sendInput({ type: 'input', input: 'mouse', action: 'click', button: 'left' });
				}
				lastClientPos = null;
			});

			// ホイール（2本指スクロールは wheel イベントになる）
			overlay.addEventListener('wheel', (e) => {
				e.preventDefault();
				sendInput({ type: 'input', input: 'wheel', deltaX: e.deltaX, deltaY: e.deltaY });
			}, { passive: false });

			// 左右の UI ボタン -> マウスクリックを送信（左ボタンは右クリック、右ボタンは左クリック）
			const leftBtnEl = document.getElementById('leftBtn');
			const rightBtnEl = document.getElementById('rightBtn');
			if (leftBtnEl) {
				leftBtnEl.addEventListener('click', (ev) => {
					ev.preventDefault();
					sendInput({ type: 'input', input: 'mouse', action: 'click', button: 'right' });
				});
			}
			if (rightBtnEl) {
				rightBtnEl.addEventListener('click', (ev) => {
					ev.preventDefault();
					sendInput({ type: 'input', input: 'mouse', action: 'click', button: 'left' });
				});
			}

			// タッチ処理: シングルフィンガーは相対マウス、2本指はスクロール
			let twoFinger = false;
			let lastTwoCenterY = null;
			let lastTouchPos = null;
			let touchStartTime = 0;
			let touchMoved = false;
			const TAP_MAX_MS = 250;
			const TAP_MOVE_PX = 10;

			overlay.addEventListener('touchstart', (e) => {
				e.preventDefault();
				if (e.touches.length === 1) {
					const t = e.touches[0];
					lastTouchPos = { x: t.clientX, y: t.clientY };
					isTouchActive = true;
					touchStartTime = Date.now();
					touchMoved = false;
					twoFinger = false;
				} else if (e.touches.length === 2) {
					twoFinger = true;
					const cY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
					lastTwoCenterY = cY;
					lastTouchPos = null;
				}
			}, { passive: false });

			overlay.addEventListener('touchmove', (e) => {
				e.preventDefault();
				if (twoFinger && e.touches.length === 2) {
					const cY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
					const dy = cY - (lastTwoCenterY || cY);
					lastTwoCenterY = cY;
					// ホイールとして送信
					sendInput({ type: 'input', input: 'wheel', deltaX: 0, deltaY: dy });
				} else if (e.touches.length === 1) {
					const t = e.touches[0];
					if (!overlayRect) updateOverlay();
					if (lastTouchPos == null) {
						lastTouchPos = { x: t.clientX, y: t.clientY };
						return;
					}
					const dx = t.clientX - lastTouchPos.x;
					const dy = t.clientY - lastTouchPos.y;
					if (Math.hypot(dx, dy) > TAP_MOVE_PX) touchMoved = true;
					lastTouchPos = { x: t.clientX, y: t.clientY };
					const normDx = dx / overlayRect.width;
					const normDy = dy / overlayRect.height;
					scheduleRelativeMove(normDx, normDy);
				}
			}, { passive: false });

			overlay.addEventListener('touchend', (e) => {
				e.preventDefault();
				if (!twoFinger && e.changedTouches.length === 1) {
					const dt = Date.now() - touchStartTime;
					// タップでのクリックは無効化: touchend でクリックを送らない
					lastTouchPos = null;
				}
				if (e.touches.length < 2) {
					twoFinger = false;
					lastTwoCenterY = null;
				}
				// タッチの直後は合成マウスイベントを短時間無視する
				setTimeout(() => { isTouchActive = false; }, 200);
			}, { passive: false });

				// ICE candidate の送信
				pc.onicecandidate = (event) => {
					if (event.candidate) {
						if (ws && ws.readyState === WebSocket.OPEN && isOfferSent) {
							ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
						} else {
							candidateQueue.push(event.candidate);
						}
					}
				};

				// トラック受信（映像・音声）
				pc.ontrack = (event) => {
					if (video.srcObject !== event.streams[0]) {
						video.srcObject = event.streams[0];
					}

					// 音声トラックが来たら解析をセット
					if (event.track.kind === 'audio') {
						try {
							if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
							// 既に解析器がある場合は再利用
							if (!analyser) {
								analyser = audioCtx.createAnalyser();
								analyser.fftSize = 512;
								dataArray = new Uint8Array(analyser.fftSize);
							}
							const srcStream = event.streams[0];
							const source = audioCtx.createMediaStreamSource(srcStream);
							source.connect(analyser);
							// 定期的にRMSを計算してUI更新
							if (volInterval) clearInterval(volInterval);
							volInterval = setInterval(() => {
								analyser.getByteTimeDomainData(dataArray);
								let sum = 0;
								for (let i = 0; i < dataArray.length; i++) {
									const v = (dataArray[i] - 128) / 128;
									sum += v * v;
								}
								const rms = Math.sqrt(sum / dataArray.length);
								const display = Math.min(100, Math.round(rms * 200));
								document.getElementById('volBar').style.width = display + '%';
								document.getElementById('volText').textContent = display;
								// console.log(`受信音量: ${display}%`);
							}, 200);
							try { video.play().catch(()=>{}); } catch(e) {}
						} catch (e) {
							console.error('audio analyse error', e);
						}
					}
				};

				pc.onconnectionstatechange = () => {
					console.log('PC connectionState=', pc.connectionState);
					if (pc.connectionState === 'connected') setConnectionStatus('connected');
					else if (pc.connectionState === 'connecting') setConnectionStatus('connecting');
					else setConnectionStatus('stopped');
				};

				console.log('connect handler finished');
				setConnectionStatus('connecting');
			} catch (error) {
				console.error('接続エラー:', error);
				setConnectionStatus('stopped');
			}
		});

		// 切断処理
		disconnectBtn.addEventListener('click', async () => {
			try {
				// WebSocketを閉じる
				if (ws) {
					ws.close();
					ws = null;
				}

				// PeerConnectionを閉じる
				if (pc) {
					pc.getSenders().forEach((sender) => pc.removeTrack(sender));
					pc.close();
					pc = null;
				}

				// ビデオストリームを停止
				if (video.srcObject) {
					const tracks = video.srcObject.getTracks();
					tracks.forEach((track) => track.stop());
					video.srcObject = null;
				}

				console.log('切断しました');
				setConnectionStatus('stopped');
			} catch (error) {
				console.error('切断エラー:', error);
				setConnectionStatus('stopped');
			}
		});
	</script>
</body>
</html>
