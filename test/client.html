<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Remote Desktop Client</title>
</head>
<body style="margin:0; background:#000; height:100vh; width:100vw; overflow:hidden;">
	<div style="display:flex; flex-direction:column; height:100vh; width:100vw;">
		<!-- 上黒帯 -->
		<div style="flex:0 0 5vh; background:#000;"></div>
		<!-- メインコンテンツ -->
		<div style="flex:1; display:flex; flex-direction:row; align-items:center; justify-content:space-between; background:#000; width:100vw;">
			<!-- 左ボタン -->
			<button id="leftBtn" style="flex:0 0 6vw; height:80vh; margin-left:1vw; font-size:2vw; align-self:center;">◀</button>
			<!-- ビデオ -->
			<div style="flex:1; display:flex; align-items:center; justify-content:center;">
				<video id="remoteVideo" autoplay playsinline 
					style="width:100%; max-width:100vw; max-height:80vh; aspect-ratio:16/9; background:#000; border-radius:1vw; box-shadow:0 0 20px #222;"></video>
			</div>
			<!-- 右ボタン -->
			<button id="rightBtn" style="flex:0 0 6vw; height:80vh; margin-right:1vw; font-size:2vw; align-self:center;">▶</button>
		</div>
		<!-- 下黒帯 -->
		<div style="flex:0 0 5vh; background:#000;"></div>
	</div>

	<!-- メニュー -->
	<div id="menu" style="position:fixed; top:0; right:-200px; width:200px; height:100%; background:#333; color:#fff; box-shadow:-5px 0 10px rgba(0,0,0,0.5); transition:right 0.3s;">
		<button id="connectBtn" style="width:100%; padding:10px; background:#4CAF50; color:#fff; border:none;">接続</button>
		<button id="disconnectBtn" style="width:100%; padding:10px; background:#f44336; color:#fff; border:none;">切断</button>

		<!-- 音量メーター -->
		<div style="margin-top:12px; padding:10px; font-size:14px;">
			<div style="margin-bottom:6px; color:#fff;">受信音量: <span id="volText">0</span>%</div>
			<div style="width:100%; height:12px; background:#555; border-radius:6px; overflow:hidden;">
				<div id="volBar" style="width:0%; height:100%; background:#0f0; transition:width 0.1s;"></div>
			</div>
		</div>

		<!-- 接続状態インジケータ -->
		<div style="padding:10px; font-size:14px; color:#fff;">
			接続状態: <span id="connectionStatus" style="font-weight:bold; color:#f44;">停止中</span>
		</div>
	</div>

	<!-- メニュートグルボタン -->
	<button id="menuToggle" style="position:fixed; top:calc(50% - 40vh); right:0; transform:translateY(0); background:#333; color:#fff; border:none; border-radius:5px 0 0 5px; padding:10px;">＜</button>

	<script>
		const menu = document.getElementById('menu');
		const menuToggle = document.getElementById('menuToggle');
		let menuOpen = false;

		menuToggle.addEventListener('click', () => {
			menuOpen = !menuOpen;
			menu.style.right = menuOpen ? '0' : '-200px';
			menuToggle.textContent = menuOpen ? '>' : '<';
		});

		const connectBtn = document.getElementById('connectBtn');
		const disconnectBtn = document.getElementById('disconnectBtn');
		const ipInput = document.createElement('input');
		ipInput.type = 'text';
		ipInput.placeholder = 'サーバーIP';
		ipInput.style.width = '100%';
		ipInput.style.padding = '10px';
		ipInput.style.marginBottom = '10px';
		menu.insertBefore(ipInput, connectBtn);

		let ws = null;
		let pc = null;
		const video = document.getElementById('remoteVideo');
		let audioCtx = null;
		let isOfferSent = false;
		let candidateQueue = [];
		let analyser = null;
		let dataArray = null;
		let volInterval = null;
		const connectionStatusElem = document.getElementById('connectionStatus');

		function setConnectionStatus(state) {
			if (!connectionStatusElem) return;
			if (state === 'connected') {
				connectionStatusElem.textContent = '接続中';
				connectionStatusElem.style.color = '#0f0';
			} else if (state === 'connecting') {
				connectionStatusElem.textContent = '接続中...';
				connectionStatusElem.style.color = '#ff0';
			} else {
				connectionStatusElem.textContent = '停止中';
				connectionStatusElem.style.color = '#f44';
			}
		}

		// 接続処理
		connectBtn.addEventListener('click', async () => {
			const serverIp = ipInput.value || location.hostname;
			try {
				// WebSocketとPeerConnectionを再生成
				if (ws) {
					ws.close();
				}
				ws = new WebSocket(`ws://${serverIp}:8765`);

				if (pc) {
					pc.close();
				}
				pc = new RTCPeerConnection();

				// トランシーバーを追加
				pc.addTransceiver('video', { direction: 'recvonly' });
				pc.addTransceiver('audio', { direction: 'recvonly' });

				// シグナリング: offer送信
				const offer = await pc.createOffer();
				// create AudioContext on user gesture (connect button)
				audioCtx = new (window.AudioContext || window.webkitAudioContext)();
				await pc.setLocalDescription(offer);
				const handleWsOpen = () => {
					ws.send(JSON.stringify({ sdp: offer.sdp, type: offer.type }));
					isOfferSent = true;
					// flush queued candidates
					while (candidateQueue.length) {
						const c = candidateQueue.shift();
						ws.send(JSON.stringify({ type: 'candidate', candidate: c }));
					}
				};
				ws.onopen = handleWsOpen;
				// if websocket already opened (rare), call handler immediately
				if (ws.readyState === WebSocket.OPEN) {
					handleWsOpen();
				}

				// シグナリング: answer/ICE candidate受信
				ws.onmessage = async (event) => {
					const msg = JSON.parse(event.data);
					if (msg.type === 'answer') {
						await pc.setRemoteDescription(new RTCSessionDescription(msg));
					} else if (msg.type === 'candidate' && msg.candidate) {
						await pc.addIceCandidate(msg.candidate);
					}
				};

				// ICE candidate送信
				pc.onicecandidate = (event) => {
					if (event.candidate) {
						if (ws && ws.readyState === WebSocket.OPEN && isOfferSent) {
							ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
						} else {
							candidateQueue.push(event.candidate);
						}
					}
				};

				// トラック受信（映像・音声）
				pc.ontrack = (event) => {
					if (video.srcObject !== event.streams[0]) {
						video.srcObject = event.streams[0];
					}

					// 音声トラックが来たら解析をセット
					if (event.track.kind === 'audio') {
						try {
							if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
							// 既に解析器がある場合は再利用
							if (!analyser) {
								analyser = audioCtx.createAnalyser();
								analyser.fftSize = 512;
								dataArray = new Uint8Array(analyser.fftSize);
							}
							const srcStream = event.streams[0];
							const source = audioCtx.createMediaStreamSource(srcStream);
							source.connect(analyser);
							// 定期的にRMSを計算してUI更新
							if (volInterval) clearInterval(volInterval);
							volInterval = setInterval(() => {
								analyser.getByteTimeDomainData(dataArray);
								let sum = 0;
								for (let i = 0; i < dataArray.length; i++) {
									const v = (dataArray[i] - 128) / 128;
									sum += v * v;
								}
								const rms = Math.sqrt(sum / dataArray.length);
								const display = Math.min(100, Math.round(rms * 200));
								document.getElementById('volBar').style.width = display + '%';
								document.getElementById('volText').textContent = display;
								// console.log(`Client Volume: ${display}%`);
							}, 200);
							try { video.play().catch(()=>{}); } catch(e) {}
						} catch (e) {
							console.error('audio analyse error', e);
						}
					}
				};

				pc.onconnectionstatechange = () => {
					console.log('PC connectionState=', pc.connectionState);
					if (pc.connectionState === 'connected') setConnectionStatus('connected');
					else if (pc.connectionState === 'connecting') setConnectionStatus('connecting');
					else setConnectionStatus('stopped');
				};

				console.log('connect handler finished');
				setConnectionStatus('connecting');
			} catch (error) {
				console.error('接続エラー:', error);
				setConnectionStatus('stopped');
			}
		});

		// 切断処理
		disconnectBtn.addEventListener('click', async () => {
			try {
				// WebSocketを閉じる
				if (ws) {
					ws.close();
					ws = null;
				}

				// PeerConnectionを閉じる
				if (pc) {
					pc.getSenders().forEach((sender) => pc.removeTrack(sender));
					pc.close();
					pc = null;
				}

				// ビデオストリームを停止
				if (video.srcObject) {
					const tracks = video.srcObject.getTracks();
					tracks.forEach((track) => track.stop());
					video.srcObject = null;
				}

				console.log('切断しました');
				setConnectionStatus('stopped');
			} catch (error) {
				console.error('切断エラー:', error);
				setConnectionStatus('stopped');
			}
		});
	</script>
</body>
</html>
